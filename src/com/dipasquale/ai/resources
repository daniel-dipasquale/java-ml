neat (main resources):
http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf
http://nn.cs.utexas.edu/downloads/papers/stanley.gecco02_1.pdf
http://nn.cs.utexas.edu/downloads/papers/stanley.phd04.pdf
https://www.heatonresearch.com/encog/ (very good)
https://www.heatonresearch.com/encog/neat/neat_structure.html (very good)
https://neat-python.readthedocs.io/en/latest/xor_example.html
https://www.cs.cmu.edu/afs/cs/project/jair/pub/volume21/stanley04a-html/node3.html
https://www.cs.ucf.edu/~kstanley/neat.html
https://neat-python.readthedocs.io/en/latest/ctrnn.html

other stuff:
http://nn.cs.utexas.edu/downloads/papers/AdityaRawalThesis.pdf

pitStop:
https://ai.stackexchange.com/questions/6231/how-to-evaluate-a-neat-neural-network

neat (other resources):
https://github.com/Luecx/NEAT/blob/master/vid%203/src/data_structures/RandomHashSet.java
https://github.com/colgreen/sharpneat-refactor/blob/master/src/SharpNeat/NeuralNets/Double/NeuralNetAcyclic.cs
https://github.com/hydrozoa-yt/hydroneat/blob/master/src/com/hydrozoa/hydroneat/Genome.java
https://github.com/jeffheaton/encog-java-examples/blob/master/src/main/java/org/encog/examples/neural/neat/XORNEAT.java (very good)
https://github.com/wagenaartje/neataptic/blob/master/src/architecture/architect.js
https://neat-python.readthedocs.io/en/latest/neat_overview.html
https://pastebin.com/ZZmSNaHX
https://vbstudio.hu/en/blog/20190317-Growing-an-AI-with-NEAT
https://wagenaartje.github.io/neataptic/docs/builtins/gru/
https://www.freecodecamp.org/news/how-to-use-ai-to-play-sonic-the-hedgehog-its-neat-9d862a2aef98/
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2758373/
https://www.youtube.com/watch?v=1I1eG-WLLrY&ab_channel=Hydrozoa
https://www.youtube.com/watch?v=MPFWsRjDmnU&ab_channel=TechWithTim
https://www.youtube.com/watch?v=nhT56blfRpE&ab_channel=KieCodes
https://www.youtube.com/watch?v=vvSjJZDPQVc&ab_channel=FinnEggers

examples (activation):
https://github.com/colgreen/sharpneat-refactor/tree/master/src/SharpNeat/NeuralNets/Double/ActivationFunctions
https://github.com/wagenaartje/neataptic/blob/master/src/methods/activation.js

examples (articles):
https://medium.com/@yashwanthgajji/offline-multiplayer-game-bot-using-the-neat-algorithm-6b2a31afba7f

questions:
https://ai.stackexchange.com/questions/2689/how-does-mating-take-place-in-neat
https://stackoverflow.com/questions/45390481/what-is-neat-neuroevolution-of-augmenting-topologies
https://stackoverflow.com/questions/47898104/adjusted-fitness-in-neat-algorithm
https://stackoverflow.com/questions/50960834/neat-speciating
https://stackoverflow.com/questions/55569260/feedforward-algorithm-in-neat-neural-evolution-of-augmenting-topologies
https://stackoverflow.com/questions/65895442/neat-what-to-do-with-single-member-species

issues:
fix the way disconnected nodes are persisted
fix the context properties, maybe implement a few to realize what's over done
fix the speciation and evolution
fix the way the classes are organized
provide a way to save the genomes

topological sort:
http://sergebg.blogspot.com/2014/11/non-recursive-dfs-topological-sort.html

- example:

//        DequeMap<SequentialId, Neuron> ordered = new DequeMap<>();
//        DequeMap<NavigationId, PitStop<T>> stack = new DequeMap<>();
//
//        for (NeuronStrategy<T> neuron : outputNeurons) {
//            stack.put(new NavigationId(neuron.getId(), 0), PitStop.createNotReady(neuron));
//
//            while (!stack.isEmpty()) {
//                PitStop<T> pitStop = stack.removeLast();
//
//                if (!pitStop.ready) {
//                    stack.put(new NavigationId(pitStop.neuron.getId(), 0), PitStop.createReady(pitStop.neuron));
//
//                    for (SequentialId id : pitStop.neuron.getInputIds()) {
//                        PitStop<T> pitStopOld = stack.get(id);
//
//                        if (pitStopOld != null && !pitStopOld.ready) {
//                            stack.putLast(new NavigationId(id, 0), pitStopOld);
//                        } else if (pitStopOld == null && !ordered.containsKey(id)) {
//                            stack.put(new NavigationId(id, 0), PitStop.createNotReady(neurons.get(id)));
//                        } else {
//                            pitStop.neuron.promoteToRecurrent();
//                        }
//                    }
//                } else {
//                    orderedAlready.add(pitStop.neuron.getId());
//                    ordered.add(pitStop.neuron);
//                }
//            }
//        }
//
//        return ordered;

    @RequiredArgsConstructor(access = AccessLevel.PACKAGE)
    @EqualsAndHashCode
    private static final class NavigationId {
        private final SequentialId id;
        private final int cycle;

        @Generated
        @Override
        public String toString() {
            return String.format("%s:%d", id, cycle);
        }
    }

    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    private static final class PitStop<T extends Neuron> {
        private final NeuronStrategy<T> neuron;
        private final boolean ready;

        private static <T extends Neuron> PitStop<T> createNotReady(final NeuronStrategy<T> neuron) {
            return new PitStop<>(neuron, false);
        }

        private static <T extends Neuron> PitStop<T> createReady(final NeuronStrategy<T> neuron) {
            return new PitStop<>(neuron, true);
        }

        @Generated
        @Override
        public String toString() {
            return String.format("%s:%b", neuron.getId(), ready);
        }
    }

/*
package com.dipasquale.ai.rl.neat;

import com.dipasquale.ai.common.SequentialId;
import com.dipasquale.data.structure.map.DequeMap;
import lombok.AccessLevel;
import lombok.Generated;
import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

@RequiredArgsConstructor(access = AccessLevel.PACKAGE)
final class NeuronNavigator<T extends Neuron> implements Iterable<Neuron> {
    private final NeuronPromoter<T> neuronPromoter;
    private final Map<SequentialId, NeuronStrategy<T>> neurons = new HashMap<>();
    private final List<NeuronStrategy<T>> outputNeurons = new ArrayList<>();
    private Queue<Neuron> neuronsOrdered = null;

    public boolean isEmpty() {
        return neurons.isEmpty();
    }

    public Neuron get(final SequentialId id) {
        return neurons.get(id);
    }

    public void add(final Neuron neuron) {
        NeuronStrategy<T> neuronStrategy = new NeuronStrategy<>(neuronPromoter, neuron);

        neurons.put(neuron.getId(), neuronStrategy);

        if (neuron.getType() == NodeGeneType.Output) {
            outputNeurons.add(neuronStrategy);
        }

        neuronsOrdered = null;
    }

    private Queue<Neuron> createOrdered() {
        LinkedList<Neuron> ordered = new LinkedList<>();
        Set<SequentialId> orderedAlready = new HashSet<>();
        DequeMap<SequentialId, PitStop<T>> stack = new DequeMap<>();

        for (NeuronStrategy<T> neuron : outputNeurons) {
            stack.put(neuron.getId(), new PitStop<>(neuron, false));

            while (!stack.isEmpty()) {
                PitStop<T> pitStop = stack.removeLast();

                if (!pitStop.ready) {
                    stack.put(pitStop.neuron.getId(), new PitStop<>(pitStop.neuron, true));

                    for (SequentialId id : pitStop.neuron.getInputIds()) {
                        PitStop<T> pitStopOld = stack.get(id);

                        if (pitStopOld != null && !pitStopOld.ready) {
                            stack.putLast(id, pitStopOld);
                        } else if (pitStopOld == null && !orderedAlready.contains(id)) {
                            stack.put(id, new PitStop<>(neurons.get(id), false));
                        } else {
                            pitStop.neuron.promoteToRecurrent();
                        }
                    }
                } else {
                    orderedAlready.add(pitStop.neuron.getId());
                    ordered.add(pitStop.neuron);
                }
            }
        }

        return ordered;
    }

    private void ensureOrderedIsInitialized() {
        if (neuronsOrdered == null) {
            neuronsOrdered = createOrdered();
        }
    }

    public float[] getOutputValues() {
        float[] outputValues = new float[outputNeurons.size()];
        int index = 0;

        for (Neuron neuron : outputNeurons) {
            outputValues[index++] = neuron.getValue();
        }

        return outputValues;
    }

    public void clear() {
        neurons.clear();
        outputNeurons.clear();
        neuronsOrdered = null;
    }

    @Override
    public Iterator<Neuron> iterator() {
        ensureOrderedIsInitialized();

        return neuronsOrdered.iterator();
    }

    @RequiredArgsConstructor(access = AccessLevel.PACKAGE)
    private static final class NavigationId {
        private final SequentialId id;
        private final int cycle;

        @Generated
        @Override
        public String toString() {
            return String.format("%s:%d", id, cycle);
        }
    }

    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)
    private static final class PitStop<T extends Neuron> {
        private final NeuronStrategy<T> neuron;
        private final boolean ready;

        @Generated
        @Override
        public String toString() {
            return String.format("%s:%b", neuron.getId(), ready);
        }
    }
}
 */